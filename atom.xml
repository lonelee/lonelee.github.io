<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Saint Li's blog]]></title>
  <subtitle><![CDATA[Keep moving...]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-12-01T11:45:14.034Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Saint Li]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[使用RxJava提高用户体验 - Improving UX with RxJava]]></title>
    <link href="http://yoursite.com/2015/11/23/%E4%BD%BF%E7%94%A8RxJava%E6%8F%90%E9%AB%98%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    <id>http://yoursite.com/2015/11/23/使用RxJava提高用户体验/</id>
    <published>2015-11-23T13:45:21.000Z</published>
    <updated>2015-12-01T11:45:14.034Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="https://medium.com/@diolor/improving-ux-with-rxjava-4440a13b157f#.z116013ro" target="_blank" rel="external">https://medium.com/@diolor/improving-ux-with-rxjava-4440a13b157f#.z116013ro</a><br>原文作者：<a href="https://medium.com/@diolor" target="_blank" rel="external">Dionysis Lorentzos</a><br>文章推荐来自：<a href="http://androidweekly.net/" target="_blank" rel="external">Android Weekly</a></p>
<blockquote>
<p>In a perfect mobile world users would never lose connectivity, servers will never return errors and bacon would have been low fat.</p>
</blockquote>
<p>在一个完美的移动应用世界中，用户永远不会掉线，服务器永远不会返回错误码，而培根总是低脂肪的。</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/600/1*kCcW9ytw2jQwYqmvnhGjuw.gif" alt=""><br><a href="https://dribbble.com/shots/2004585-Search-animation" target="_blank" rel="external">Search list animation</a> by <a href="https://dribbble.com/daleypmaasz" target="_blank" rel="external">Daley P Maasz</a> from Dribbble.<br><a href="https://dribbble.com/shots/2004585-Search-animation" target="_blank" rel="external">搜索列表动画</a>来自Dribbble，作者<a href="https://dribbble.com/daleypmaasz" target="_blank" rel="external">Daley P Maasz</a>。</p>
<blockquote>
<p>Building a great app experience is usually a bliss for a user but pain for the developer. Gone are the days that a user clicks a button, the UI gets blocked and you wait for a backend response. It’s just <strong>frustrating</strong>.</p>
</blockquote>
<p>做一个极致用户体验的应用是一件让用户高兴的事情，但同时也是一件让开发者头疼的事情。试想那些情景，当用户点击一个按钮，界面卡死，你只能等待后台的网络回应。那真是令人沮丧。</p>
<blockquote>
<p>Let’s create today a better search functionality with an Editext and focus on the following:</p>
</blockquote>
<p>让我们用EditText做一个更好的搜索功能，专注于这些点：</p>
<blockquote>
<ul>
<li>As few network requests as possible</li>
<li>As few error messages to the user</li>
</ul>
</blockquote>
<ul>
<li>尽量少的网络请求</li>
<li>尽量少给用户展示错误信息</li>
</ul>
<blockquote>
<p>The RX logic is quite simple and focuses in perfecting minor details.</p>
</blockquote>
<p>RX逻辑是对于完善主要细节是相当简单和高效的。</p>
<blockquote>
<p>Let’s start with the basic logic:</p>
</blockquote>
<p>我们从基本逻辑开始：</p>
<blockquote>
<p>Whenever the user types something we perform a network call and then we get the results:</p>
</blockquote>
<p>当用户输入字符的时候，我们发起一个网络请求，然后获取返回的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RxTextView.textChanges(searchEditText)</span><br><span class="line">     .flatMap(Api::searchItems)</span><br><span class="line">     .subscribe(<span class="keyword">this</span>::updateList, t-&gt;showError());</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="Reduce_network_requests-">Reduce network requests.</h2></blockquote>
<h2 id="减少网络请求。">减少网络请求。</h2><blockquote>
<p>The above has two problems:</p>
</blockquote>
<p>上面的代码有两个问题：</p>
<blockquote>
<ul>
<li>you make a request per letter (yes that’s bad) e.g.: user types quickly “a”, then “ab” then “abc” then corrects to “ab” and want to search finally for “abe”. You have made 5 network requests. Imagine if there is slow internet connectivity.</li>
<li>you have a threading race possible problem e.g: user types “a”, then “ab”. The network call for the “ab” comes first and the call for “a” second. In that case the last updateList() will get executed with results from the “a”.</li>
</ul>
</blockquote>
<ul>
<li>每个字符（的改变）都会发起一次请求（是的，这是不好的），例如：用户快速的输入“a”，接着“ab”，接着“abc”，接着重新修改为“ab”，然而最后想要搜索的是“abe”。你发起了5次网络请求，试想下在网络连接缓慢的情况下会多糟糕。</li>
<li>后台线程会引起潜在的问题，例如：用户输入“a”，接着是“ab”。一旦网络请求“ab”的请求先返回，过一会“a”的请求再返回，在这种情况下最后一次调用updateList()将会显示“a”的结果。</li>
</ul>
<blockquote>
<p><strong>Solutions</strong> :</p>
</blockquote>
<p><strong>解决方法</strong>：</p>
<blockquote>
<h3 id="Add_throttling_behaviour:">Add throttling behaviour:</h3></blockquote>
<h3 id="添加阀值控制：">添加阀值控制：</h3><blockquote>
<p><a href="http://reactivex.io/documentation/operators/debounce.html" target="_blank" rel="external">debounce()</a> is what you usually need. Values between 100–150 millis from my experience work the best. If your server needs additionally another 300ms then you can do a UI update in under 0.5 seconds.</p>
</blockquote>
<p><a href="http://reactivex.io/documentation/operators/debounce.html" target="_blank" rel="external">debounce()</a> 正是你需要的方法。按照我的工作经验，延迟的值在100-150毫秒是最佳的。如果你的服务器需要多300毫秒来返回结果，那么你就可以在0.5秒内去更新UI界面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RxTextView.textChanges(searchEditText)</span><br><span class="line">     .debounce(<span class="number">150</span>, MILLISECONDS)</span><br><span class="line">     .flatMap(Api::searchItems)</span><br><span class="line">     .subscribe(<span class="keyword">this</span>::updateList, t-&gt;showError());</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="Kill_the_previous_requests:">Kill the previous requests:</h3></blockquote>
<h3 id="移除上一次请求：">移除上一次请求：</h3><blockquote>
<p>introduce <a href="http://reactivex.io/documentation/operators/flatmap.html" target="_blank" rel="external">switchMap</a> instead of flatMap. It will stop the previously emitted items. So if in time 0+150ms you search for “ab” and in time 0+300ms you search for “abcd” but the “ab” network call needs more than 150ms to complete, then by the time you start the “abcd” call the previous one will get canceled and you will always have the most recent result.</p>
</blockquote>
<p>采用<a href="http://reactivex.io/documentation/operators/flatmap.html" target="_blank" rel="external">switchMap</a>方法来替代flatMap方法。这个方法将会停止先前发送的数据，因此如果在0-150毫秒的时候你搜索了“ab”，接着在0-300毫秒的时候你搜索了“abcd”，而“ab”的请求结果需要150毫秒后才能够返回，那么当你发起“abcd”搜索请求的时候，之前的请求将会被取消掉，你总可以获取到最近请求的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RxTextView.textChanges(searchEditText)</span><br><span class="line">     .debounce(<span class="number">150</span>, MILLISECONDS)</span><br><span class="line">     .switchMap(Api::searchItems)</span><br><span class="line">     .subscribe(<span class="keyword">this</span>::updateList, t-&gt;showError());</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="No_error_functionality_/_no_network_functionality">No error functionality / no network functionality</h2></blockquote>
<h2 id="没有错误处理功能/没有网络功能">没有错误处理功能/没有网络功能</h2><blockquote>
<p>If a network call fails, you will never again observe text changes.<br>This can be easily solved by adding some <a href="https://github.com/ReactiveX/RxJava/wiki/Error-Handling-Operators" target="_blank" rel="external">error catching functionality</a>.<br>So you could just use:</p>
</blockquote>
<p>如果一个网络请求失败了，你将再也不能跟随文字改变去发起请求。这个问题可以很容易地解决，只需要增加一些<a href="https://github.com/ReactiveX/RxJava/wiki/Error-Handling-Operators" target="_blank" rel="external">错误捕获功能</a>。</p>
<p>你可以使用以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RxTextView.textChanges(searchEditText)</span><br><span class="line">     .debounce(<span class="number">150</span>, MILLISECONDS)</span><br><span class="line">     .switchMap(Api::searchItems)</span><br><span class="line">     .onErrorResumeNext(t-&gt; empty())</span><br><span class="line">     .subscribe(<span class="keyword">this</span>::updateList);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Don’t do that. Let’s make it smarter. What if the searchItems() api call above calls because of connectivity? Or even more “UX-depressingly” brief connectivity that the user didn’t notice?</p>
</blockquote>
<p>别这么做。让我们把它变得更智能一点。要是searchItems()的调用因为网络连接的问题发生在其它调用之前呢？</p>
<blockquote>
<p>You need a retry mechanism for these:</p>
</blockquote>
<p>你需要一个重试机制来解决这些问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RxTextView.textChanges(searchEditText)</span><br><span class="line">     .debounce(<span class="number">150</span>, MILLISECONDS)</span><br><span class="line">     .switchMap(Api::searchItems)</span><br><span class="line">     .retryWhen(<span class="keyword">new</span> RetryWithConnectivity())</span><br><span class="line">     .subscribe(<span class="keyword">this</span>::updateList, t-&gt;showError());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>How to improve it even further? By adding a timeout. As our (car2go) UX designer Leander Lenzing says, “1 second is a lot of time in the user world”. So the above should be something like:</p>
</blockquote>
<p>怎样把这个功能变得更完善呢？通过增加一个超时保护。就像我们的用户体验设计负责人Lenzing所说的，“在用户看来，1秒钟是相当长的一段时间。”因此，上面的代码应该是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RxTextView.textChanges(searchEditText)</span><br><span class="line">     .debounce(<span class="number">150</span>, MILLISECONDS)</span><br><span class="line">     .switchMap(Api::searchItems)</span><br><span class="line">     .retryWhen(<span class="keyword">new</span> RetryWithConnectivityIncremental(context, <span class="number">5</span>, <span class="number">15</span>, SECONDS))</span><br><span class="line">     .subscribe(<span class="keyword">this</span>::updateList, t-&gt;showErrorToUser());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>So what will RetryWithConnectivityIncremental vs RetryWithConnectivity do? It will wait 5 seconds the phone to have internet, if more it will throw an exception. If the user retries it will wait with a longer timeout (e.g. 15 seconds).</p>
</blockquote>
<p>那么RetryWithConnectivityIncremental和RetryWithConnectivity做了什么呢？它将有5秒钟等待手机重新连网，如果超过了这个时间会抛出异常。如果是用户手动重试，那么将会有一个更长一点的超时（例如15秒）</p>
<blockquote>
<p>Here is the code:</p>
</blockquote>
<p>以下是实现代码：</p>
<blockquote>
<p><a href="https://gist.github.com/Diolor/a17ddb78d3d45b452f02#file-broadcastobservable-java" target="_blank" rel="external">BroadcastObservable.java</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.BroadcastReceiver;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.IntentFilter;</span><br><span class="line"><span class="keyword">import</span> android.net.ConnectivityManager;</span><br><span class="line"><span class="keyword">import</span> android.net.NetworkInfo;</span><br><span class="line"><span class="keyword">import</span> android.os.Looper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rx.Observable;</span><br><span class="line"><span class="keyword">import</span> rx.Scheduler;</span><br><span class="line"><span class="keyword">import</span> rx.Subscriber;</span><br><span class="line"><span class="keyword">import</span> rx.Subscription;</span><br><span class="line"><span class="keyword">import</span> rx.android.schedulers.AndroidSchedulers;</span><br><span class="line"><span class="keyword">import</span> rx.functions.Action0;</span><br><span class="line"><span class="keyword">import</span> rx.subscriptions.Subscriptions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastObservable</span> <span class="keyword">implements</span> <span class="title">Observable</span>.<span class="title">OnSubscribe</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Context context;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;Boolean&gt; <span class="title">fromConnectivityManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Observable.create(<span class="keyword">new</span> BroadcastObservable(context))</span><br><span class="line">				.share();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BroadcastObservable</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.context = context;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Boolean&gt; subscriber)</span> </span>&#123;</span><br><span class="line">		BroadcastReceiver receiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">			<span class="annotation">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">				subscriber.onNext(isConnectedToInternet());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		context.registerReceiver(receiver, <span class="keyword">new</span> IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));</span><br><span class="line"></span><br><span class="line">		subscriber.add(unsubscribeInUiThread(() -&gt; context.unregisterReceiver(receiver)));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isConnectedToInternet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ConnectivityManager manager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">		NetworkInfo networkInfo = manager.getActiveNetworkInfo();</span><br><span class="line">		<span class="keyword">return</span> networkInfo != <span class="keyword">null</span> &amp;&amp; networkInfo.isConnected();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Subscription <span class="title">unsubscribeInUiThread</span><span class="params">(<span class="keyword">final</span> Action0 unsubscribe)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Subscriptions.create(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">if</span> (Looper.getMainLooper() == Looper.myLooper()) &#123;</span><br><span class="line">				unsubscribe.call();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">final</span> Scheduler.Worker inner = AndroidSchedulers.mainThread().createWorker();</span><br><span class="line">				inner.schedule(() -&gt; &#123;</span><br><span class="line">					unsubscribe.call();</span><br><span class="line">					inner.unsubscribe();</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://gist.github.com/Diolor/a17ddb78d3d45b452f02#file-retrywithconnectivityincremental-java" target="_blank" rel="external">RetryWithConnectivityIncremental.java</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"><span class="keyword">import</span> rx.Observable;</span><br><span class="line"><span class="keyword">import</span> rx.functions.Func1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryWithConnectivityIncremental</span> <span class="keyword">implements</span> <span class="title">Func1</span>&lt;<span class="title">Observable</span>&lt;? <span class="keyword">extends</span> <span class="title">Throwable</span>&gt;, <span class="title">Observable</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxTimeout;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> TimeUnit timeUnit;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Observable&lt;Boolean&gt; isConnected;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> startTimeOut;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RetryWithConnectivityIncremental</span><span class="params">(Context context, <span class="keyword">int</span> startTimeOut, <span class="keyword">int</span> maxTimeout, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.startTimeOut = startTimeOut;</span><br><span class="line">		<span class="keyword">this</span>.maxTimeout = maxTimeout;</span><br><span class="line">		<span class="keyword">this</span>.timeUnit = timeUnit;</span><br><span class="line">		<span class="keyword">this</span>.timeout = startTimeOut;</span><br><span class="line">		isConnected = getConnectedObservable(context);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Observable&lt;?&gt; call(Observable&lt;? extends Throwable&gt; observable) &#123;</span><br><span class="line">		<span class="keyword">return</span> observable.flatMap((Throwable throwable) -&gt; &#123;</span><br><span class="line">			<span class="keyword">if</span> (throwable <span class="keyword">instanceof</span> RetrofitError &amp;&amp; ((RetrofitError) throwable).getKind() == RetrofitError.Kind.NETWORK) &#123;</span><br><span class="line">				<span class="keyword">return</span> isConnected;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> Observable.error(throwable);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).compose(attachIncementalTimeout());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Observable.Transformer&lt;Boolean, Boolean&gt; attachIncementalTimeout() &#123;</span><br><span class="line">		<span class="keyword">return</span> observable -&gt; observable.timeout(timeout, timeUnit)</span><br><span class="line">				.doOnError(throwable -&gt; &#123;</span><br><span class="line">					<span class="keyword">if</span> (throwable <span class="keyword">instanceof</span> TimeoutException) &#123;</span><br><span class="line">						timeout = timeout &gt; maxTimeout ? maxTimeout : timeout + startTimeOut;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Observable&lt;Boolean&gt; <span class="title">getConnectedObservable</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BroadcastObservable.fromConnectivityManager(context)</span><br><span class="line">				.distinctUntilChanged()</span><br><span class="line">				.filter(isConnected -&gt; isConnected);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>So there, you have it! You throttle your request, you have always the latest results, you have a retry on connectivity mechanism with a smart timeout.</p>
</blockquote>
<p>看，你做到了！你控制了你的请求，你获取到的总是最新的结果，你有个包含智能超时处理的网络重试机制。</p>
<blockquote>
<p>The users will never notice, that’s a good design. ;)</p>
</blockquote>
<p>你的用户将永远不会感知到背后的操作，这个设计棒极了。;)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文地址：<a href="https://medium.com/@diolor/improving-ux-with-rxjava-4440a13b157f#.z116013ro" target="_blank" rel="external">https://medium.]]>
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Rxjava" scheme="http://yoursite.com/tags/Rxjava/"/>
    
      <category term="UX" scheme="http://yoursite.com/tags/UX/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android动画效果实现]]></title>
    <link href="http://yoursite.com/2015/11/04/Android%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2015/11/04/Android动画效果实现/</id>
    <published>2015-11-04T06:11:40.000Z</published>
    <updated>2015-11-04T06:26:33.214Z</updated>
    <content type="html"><![CDATA[<h1 id="View_Animation（Tween_Animation）">View Animation（Tween Animation）</h1><p>补间动画(Tween Animation)：给出两个关键帧，通过一些算法将给定属性值在给定的时间内在两个关键帧间渐变。</p>
<p>补间动画只能应用于View对象，而且只支持一部分属性，如支持缩放旋转而不支持背景颜色的改变，它包含了以下几种类型：Alpha，Scale，Translate，Rotate。</p>
<hr>
<h2 id="Alpha_渐变透明度动画效果">Alpha 渐变透明度动画效果</h2><p>Java类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AlphaAnimation</span><br></pre></td></tr></table></figure>
<p>XML文件定义</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">set</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">alpha</span></span><br><span class="line">    <span class="attribute">android:fromAlpha</span>=<span class="value">"0.1"</span></span><br><span class="line">    <span class="attribute">android:toAlpha</span>=<span class="value">"1.0"</span></span><br><span class="line">    <span class="attribute">android:duration</span>=<span class="value">"3000"</span> /&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 透明度控制动画效果 alpha</span><br><span class="line">        浮点型值：</span><br><span class="line">            fromAlpha 属性为动画起始时透明度</span><br><span class="line">            toAlpha   属性为动画结束时透明度</span><br><span class="line">            说明: </span><br><span class="line">                0.0表示完全透明</span><br><span class="line">                1.0表示完全不透明</span><br><span class="line">            以上值取0.0-1.0之间的float数据类型的数字</span><br><span class="line"></span><br><span class="line">        长整型值：</span><br><span class="line">            duration  属性为动画持续时间</span><br><span class="line">            说明:     </span><br><span class="line">                时间以毫秒为单位</span><br><span class="line">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">set</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Scale_渐变尺寸伸缩动画效果">Scale 渐变尺寸伸缩动画效果</h2><p>Java类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScaleAnimation</span><br></pre></td></tr></table></figure>
<p>XML文件定义</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">set</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">scale</span>  </span><br><span class="line">        <span class="attribute">android:interpolator</span>=<span class="value">"@android:anim/accelerate_interpolator"</span></span><br><span class="line">        <span class="attribute">android:fromXScale</span>=<span class="value">"0.0"</span></span><br><span class="line">        <span class="attribute">android:toXScale</span>=<span class="value">"1.4"</span></span><br><span class="line">        <span class="attribute">android:fromYScale</span>=<span class="value">"0.0"</span></span><br><span class="line">        <span class="attribute">android:toYScale</span>=<span class="value">"1.4"</span></span><br><span class="line">        <span class="attribute">android:pivotX</span>=<span class="value">"50%"</span></span><br><span class="line">        <span class="attribute">android:pivotY</span>=<span class="value">"50%"</span></span><br><span class="line">        <span class="attribute">android:fillAfter</span>=<span class="value">"false"</span></span><br><span class="line">        <span class="attribute">android:duration</span>=<span class="value">"700"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 尺寸伸缩动画效果 scale</span><br><span class="line"></span><br><span class="line">       属性：interpolator 指定一个动画的插值器</span><br><span class="line">       这里只能使用系统默认的动画插值器，有三种动画:</span><br><span class="line">            accelerate_decelerate_interpolator  加速-减速 动画插入器</span><br><span class="line">            accelerate_interpolator        加速-动画插入器</span><br><span class="line">            decelerate_interpolator        减速- 动画插入器</span><br><span class="line">       其他的属于特定的动画效果</span><br><span class="line"></span><br><span class="line">       浮点型值：          </span><br><span class="line">            fromXScale 属性为动画起始时X坐标上的伸缩尺寸    </span><br><span class="line">            toXScale   属性为动画结束时X坐标上的伸缩尺寸        </span><br><span class="line">            fromYScale 属性为动画起始时Y坐标上的伸缩尺寸    </span><br><span class="line">            toYScale   属性为动画结束时Y坐标上的伸缩尺寸             </span><br><span class="line">            说明:</span><br><span class="line">                 以上四种属性值         </span><br><span class="line">                    0.0表示收缩到没有 </span><br><span class="line">                    1.0表示正常无伸缩     </span><br><span class="line">                    值小于1.0表示收缩  </span><br><span class="line">                    值大于1.0表示放大         </span><br><span class="line">            pivotX     属性为动画相对于物件的X坐标的开始位置</span><br><span class="line">            pivotY     属性为动画相对于物件的Y坐标的开始位置         </span><br><span class="line">            说明:</span><br><span class="line">                    以上两个属性值 从0%-100%中取值</span><br><span class="line">                    50%为物件的X或Y方向坐标上的中点位置</span><br><span class="line">         </span><br><span class="line">      长整型值：</span><br><span class="line">            duration  属性为动画持续时间</span><br><span class="line">            说明:   时间以毫秒为单位</span><br><span class="line"> </span><br><span class="line">      布尔型值:</span><br><span class="line">            fillAfter 属性 当设置为true ，该动画转化在动画结束后被应用</span><br><span class="line">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">set</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Translate_位移动画效果">Translate 位移动画效果</h2><p>Java类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TranslateAnimation</span><br></pre></td></tr></table></figure>
<p>XML文件定义</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">set</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">translate</span></span><br><span class="line">    <span class="attribute">android:fromXDelta</span>=<span class="value">"30"</span></span><br><span class="line">    <span class="attribute">android:toXDelta</span>=<span class="value">"-80"</span></span><br><span class="line">    <span class="attribute">android:fromYDelta</span>=<span class="value">"30"</span></span><br><span class="line">    <span class="attribute">android:toYDelta</span>=<span class="value">"300"</span></span><br><span class="line">    <span class="attribute">android:duration</span>=<span class="value">"2000"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- translate 位置转移动画效果</span><br><span class="line">            整型值:</span><br><span class="line">                fromXDelta 属性为动画起始时 X坐标上的位置    </span><br><span class="line">                toXDelta   属性为动画结束时 X坐标上的位置</span><br><span class="line">                fromYDelta 属性为动画起始时 Y坐标上的位置</span><br><span class="line">                toYDelta   属性为动画结束时 Y坐标上的位置</span><br><span class="line">                注意:</span><br><span class="line">                     没有指定fromXType toXType fromYType toYType 时候，</span><br><span class="line">                     默认是以自己为相对参照物             </span><br><span class="line">            长整型值：</span><br><span class="line">                duration  属性为动画持续时间</span><br><span class="line">                说明:   </span><br><span class="line">                     时间以毫秒为单位</span><br><span class="line">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">set</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Rotate_旋转动画效果">Rotate 旋转动画效果</h2><p>Java类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RotateAnimation</span><br></pre></td></tr></table></figure>
<p>XML文件定义</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">set</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">rotate</span> </span><br><span class="line">        <span class="attribute">android:interpolator</span>=<span class="value">"@android:anim/accelerate_decelerate_interpolator"</span></span><br><span class="line">        <span class="attribute">android:fromDegrees</span>=<span class="value">"0"</span></span><br><span class="line">        <span class="attribute">android:toDegrees</span>=<span class="value">"+350"</span>        </span><br><span class="line">        <span class="attribute">android:pivotX</span>=<span class="value">"50%"</span></span><br><span class="line">        <span class="attribute">android:pivotY</span>=<span class="value">"50%"</span>    </span><br><span class="line">        <span class="attribute">android:duration</span>=<span class="value">"3000"</span> /&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- rotate 旋转动画效果</span><br><span class="line">               属性：interpolator 指定一个动画的插值器，参考上面的说明</span><br><span class="line">                                                        </span><br><span class="line">               浮点数型值:</span><br><span class="line">                    fromDegrees 属性为动画起始时物件的角度    </span><br><span class="line">                    toDegrees   属性为动画结束时物件旋转的角度 可以大于360度            </span><br><span class="line">                    说明:</span><br><span class="line">                         当角度为负数——表示逆时针旋转</span><br><span class="line">                         当角度为正数——表示顺时针旋转                     </span><br><span class="line">         </span><br><span class="line">                    pivotX     属性为动画相对于物件的X坐标的开始位置</span><br><span class="line">                    pivotY     属性为动画相对于物件的Y坐标的开始位置                         </span><br><span class="line">                    说明: </span><br><span class="line">                         以上两个属性值 从0%-100%中取值</span><br><span class="line">                         50%为物件的X或Y方向坐标上的中点位置</span><br><span class="line">         </span><br><span class="line">                长整型值：</span><br><span class="line">                    duration  属性为动画持续时间</span><br><span class="line">                    说明:     时间以毫秒为单位</span><br><span class="line">        --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">set</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="其他相关">其他相关</h2><ul>
<li>从xml文件中加载动画，可以使用 <strong>AnimationUtils</strong> 的静态方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animation <span class="title">loadAnimation</span><span class="params">(Context context, <span class="keyword">int</span> id)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Interpolator</strong> ，动画插值器，定义了动画的进行速率，在Android中内置了以下几种插值器<br>! <a href="http://i.imgur.com/dzHJpwy.png" target="_blank" rel="external"></a></li>
</ul>
<p>我们也可以通过实现该接口以下方法来自定义自己的动画插值器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">getInterpolation</span><span class="params">(<span class="keyword">float</span> input)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="Drawable_Animation（Frame_Animation）">Drawable Animation（Frame Animation）</h1><p>Drawable Animation（Frame Animation）：帧动画，就像GIF图片，通过一系列Drawable依次显示来模拟动画的效果。</p>
<hr>
<p>在XML文件 <code>/res/drawable/drawable_anim.xml</code> 中定义</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">animation-list</span> </span><br><span class="line">    <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:oneshot</span>=<span class="value">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/anim_drawable1"</span> <span class="attribute">android:duration</span>=<span class="value">"200"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/anim_drawable2"</span> <span class="attribute">android:duration</span>=<span class="value">"200"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/anim_drawable3"</span> <span class="attribute">android:duration</span>=<span class="value">"200"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>代码中调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ImageView imageView = (ImageView) findViewById(R.id.imageView);</span><br><span class="line">imageView.setBackgroundResource(R.drawable.drawable_anim);</span><br><span class="line">AnimationDrawable anim = (AnimationDrawable) imageView.getBackground();</span><br><span class="line">anim.stop();</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure>
<h1 id="Property_Animation">Property Animation</h1><p>属性动画，这个是在Android 3.0中才引进的，以前学WPF时里面的动画机制好像就是这个，它更改的是对象的实际属性，在View Animation（Tween Animation）中，其改变的是View的绘制效果，真正的View的属性保持不变，比如无论你在对话中如何缩放Button的大小，Button的有效点击区域还是没有应用动画时的区域，其位置与大小都不变。而在Property Animation中，改变的是对象的实际属性，如Button的缩放，Button的位置与大小属性值都改变了。而且Property Animation不止可以应用于View，还可以应用于任何对象。Property Animation只是表示一个值在一段时间内的改变，当值改变时要做什么事情完全是你自己决定的。</p>
<hr>
<h2 id="ValueAnimator">ValueAnimator</h2><p>ValueAnimator可以对多个属性值之间的过渡进行动画过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ValueAnimator <span class="title">ofInt</span><span class="params">(<span class="keyword">int</span>... values)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ValueAnimator <span class="title">ofFloat</span><span class="params">(<span class="keyword">float</span>... values)</span></span></span><br></pre></td></tr></table></figure>
<p>具体的使用方法例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ValueAnimator animation = ValueAnimator.ofFloat(<span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line">animation.setDuration(<span class="number">1000</span>);</span><br><span class="line">animation.addUpdateListener(<span class="keyword">new</span> AnimatorUpdateListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 动画过程中会不断回调该方法，可以取得当前动画属性值</span></span><br><span class="line">        <span class="keyword">float</span> value = (Float) animation.getAnimatedValue();</span><br><span class="line">        <span class="comment">// do something with this value</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">animation.setInterpolator(<span class="keyword">new</span> CycleInterpolator(<span class="number">3</span>));</span><br><span class="line">animation.start();</span><br></pre></td></tr></table></figure>
<h2 id="ObjectAnimator">ObjectAnimator</h2><p>继承自ValueAnimator，要指定一个对象及该对象的一个属性，当属性值计算完成时自动设置为该对象的相应属性，即完成了Property Animation的全部两步操作。实际应用中一般都会用ObjectAnimator来改变某一对象的某一属性。<br>使用ObjectAnimator有一定的 <strong>限制</strong> ，动画对象应该有一个setter函数： <code>set&lt;PropertyName&gt;</code> （驼峰命名法）和getter函数 <code>get&lt;PropertyName&gt;</code> 。</p>
<p>具体使用方法例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator oa=ObjectAnimator.ofFloat(obj, <span class="string">"alpha"</span>, <span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line">oa.setDuration(<span class="number">3000</span>);</span><br><span class="line">oa.start();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该方法用于将obj对象中的alpha属性值在3000毫秒内从0变化到1，注意该obj对象中必须有 <code>setAlpha(float value)</code> 和 <code>float getAlpha()</code> 方法。</p>
</blockquote>
<h2 id="ViewPropertyAnimator">ViewPropertyAnimator</h2><p>如果需要对一个View的多个属性进行动画可以用ViewPropertyAnimator类，该类对多属性动画进行了优化，会合并一些invalidate()来减少刷新视图。ViewPropertyAnimator可以直接对View进行平移、旋转、缩放、透明度渐变动画，动画直接改变View的属性值。</p>
<p>具体使用方法例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.animate().xBy(<span class="number">10f</span>).yBy(<span class="number">10f</span>).alphaBy(<span class="number">10f</span>).rotation(<span class="number">300f</span>).start();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在3.0之后，View类中多了一个animate()方法，可以直接返回一个ViewPropertyAnimator对象对该View进行动画；<br>如果使用NineOldAndroids低版本动画兼容库，ViewPropertyAnimator的调用方法有稍微不同</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ViewPropertyAnimator.animate(view)</span><br><span class="line">            .xBy(<span class="number">10f</span>).yBy(<span class="number">10f</span>).alphaBy(<span class="number">10f</span>).rotationBy(<span class="number">300f</span>).start();</span><br></pre></td></tr></table></figure>
<h2 id="从XML中加载">从XML中加载</h2><p>Property Animation也可以在XML中定义</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">set</span>&gt;</span> - AnimatorSet</span><br><span class="line"><span class="tag">&lt;<span class="title">animator</span>&gt;</span> - ValueAnimator</span><br><span class="line"><span class="tag">&lt;<span class="title">objectAnimator</span>&gt;</span> - ObjectAnimator</span><br></pre></td></tr></table></figure>
<p>XML文件应放大/res/animator/中，通过以下方式应用动画：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(mContext,R.anim.property_animator);</span><br><span class="line">set.setTarget(object);</span><br><span class="line">set.start();</span><br></pre></td></tr></table></figure>
<h2 id="通过AnimationSet应用多个动画">通过AnimationSet应用多个动画</h2><p>AnimatorSet提供了一个把多个动画组合成一个组合的机制，并可设置组中动画的时序关系，如同时播放，顺序播放等；相对于原来的AnimationSet，AnimatorSet更加自由。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AnimatorSet set = <span class="keyword">new</span> AnimatorSet();</span><br><span class="line">set.play(anim1).before(anim2);</span><br><span class="line">set.play(anim2).with(anim3);</span><br><span class="line">set.play(anim2).with(anim4)</span><br><span class="line">set.play(anim5).after(amin2);</span><br><span class="line">set.start();</span><br></pre></td></tr></table></figure>
<h2 id="Property_Animation和View_Animation的区别">Property Animation和View Animation的区别</h2><p>在View Animation中，对View应用Animation并没有改变View的属性，动画的实现是通过其Parent View实现的，在View被drawn时Parents View改变它的绘制参数，draw后再改变参数invalidate，这样虽然View的大小或旋转角度等改变了，但View的实际属性没变，所以有效区域还是应用动画之前的区域，比如你把一按钮放大两倍，但还是放大这前的区域可以触发点击事件。为了改变这一点，在Android 3.0中给View增加了一些参数并对这些参数增加了相应的getter/setter函数（ObjectAnimator要用这些函数改变这些属性）：</p>
<ul>
<li><strong>translationX</strong> ,  <strong>translationY</strong> : View相对于原始位置的偏移量</li>
<li><strong>rotation</strong> ,  <strong>rotationX</strong> , <strong>rotationY</strong> : 旋转，rotation用于2D旋转角度，3D中用到后两个</li>
<li><strong>scaleX</strong> ,  <strong>scaleY</strong> : 缩放比</li>
<li><strong>x</strong> ,  <strong>y</strong> : View的最终坐标，是View的left，top位置加上translationX，translationY</li>
<li><strong>alpha</strong> : 透明度</li>
</ul>
<h2 id="相关内容">相关内容</h2><ul>
<li><p>低版本动画api兼容库： <a href="https://github.com/JakeWharton/NineOldAndroids" target="_blank" rel="external">NineOldAndroids</a></p>
</li>
<li><p><a href="https://developer.android.com/guide/topics/graphics/prop-animation.html" target="_blank" rel="external">Property Animation</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/angeldevil/archive/2011/12/02/2271096.html" target="_blank" rel="external">Android动画学习笔记-Android Animation</a>  </p>
</li>
<li><p><a href="https://developer.android.com/training/animation/index.html" target="_blank" rel="external">Adding Animations</a></p>
</li>
<li><p>LayoutTransition （TODO）</p>
</li>
</ul>
<h1 id="Transition">Transition</h1><p>android.transition动画框架是在4.4版本之后加入到SDK中的，它提供了一种更直观的方式来定义动画效果。</p>
<blockquote>
<p>动态变化的应用程序用户界面提供的不仅仅是视觉吸引力；动画强调变化提供视觉线索，帮助用户了解你的应用程序是如何工作的。</p>
</blockquote>
<p>以上引用自Google对于Transition动画的介绍。</p>
<p>Transition主要用于场景之间的过渡。</p>
<hr>
<h2 id="Scene">Scene</h2><h2 id="局限">局限</h2><p>以下是关于Transition框架一些已知的使用局限</p>
<ul>
<li><p>当动画应用于SurfaceView时可能会显示异常，因为SurfaceView是在非UI线程上更新视图，导致在动画的更新上跟其他视图的动画不能同步；</p>
</li>
<li><p>一些特殊的Transition动画类型在TextureView上可能会显示异常；</p>
</li>
<li><p>继承自AdapterView的视图，例如ListView，管理子View的方式与Transition框架不兼容；因此如果你想对一个继承自AdapterView的视图做动画时可能会卡死；</p>
</li>
<li><p>如果你想对一个TextView做大小改变的动画，TextView中的文字在视图大小完全调整完毕之前会跳动到其他地方；为了避免这种问题的出现，不要对含有文字的视图做动画；</p>
</li>
</ul>
<h2 id="相关内容-1">相关内容</h2><ul>
<li><p><a href="http://developer.android.com/training/transitions/index.html" target="_blank" rel="external">Animating Views Using Scenes and Transitions</a></p>
</li>
<li><p>使用Android.Transition框架创建动画 <a href="http://blog.jobbole.com/62601/" target="_blank" rel="external">（1）</a><a href="http://blog.jobbole.com/63330/" target="_blank" rel="external">（2）</a></p>
</li>
<li><p><a href="http://mobile.51cto.com/aprogram-451555_all.htm" target="_blank" rel="external">移动开发指南：Android Transition框架介绍</a></p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="View_Animation（Tween_Animation）">View Animation（Tween Animation）</h1><p>补间动画(Tween Animation)：给出两个关键帧，通过一些算法将给定属性值在给定的时间内在两个关键帧间渐变。<]]>
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="动画" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
</feed>
